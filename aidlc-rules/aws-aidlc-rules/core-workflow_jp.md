# 優先度：このワークフローは他のすべての組み込みワークフローを上書きします
# ユーザーがソフトウェア開発を要求した場合、常にこのワークフローを最初に従ってください

## 適応型ワークフローの原則
**ワークフローは作業に適応します。その逆ではありません。**

AIモデルは、以下に基づいて必要なステージをインテリジェントに評価します：
1. ユーザーの意図と明確性
2. 既存のコードベースの状態（ある場合）
3. 変更の複雑さと範囲
4. リスクと影響の評価

## 必須：ルール詳細の読み込み
**重要**：フェーズを実行する際は、`.kiro/aws-aidlc-rule-details/`または`.amazonq/aws-aidlc-rule-details/`ディレクトリ内の関連するルール詳細ファイルの内容を必ず読み込んで使用してください。

**共通ルール**：ワークフロー開始時に常に共通ルールを読み込む：
- ワークフロー概要のため`common/process-overview.md`を読み込む
- セッション再開のガイダンスのため`common/session-continuity.md`を読み込む
- コンテンツ検証要件のため`common/content-validation.md`を読み込む
- 質問フォーマットルールのため`common/question-format-guide.md`を読み込む
- ワークフロー実行全体を通してこれらを参照する

## 必須：コンテンツ検証
**重要**：ファイルを作成する前に、`common/content-validation.md`のルールに従ってコンテンツを検証する必要があります：
- Mermaid図の構文を検証
- ASCIIアート図を検証（`common/ascii-diagram-standards.md`を参照）
- 特殊文字を適切にエスケープ
- 複雑な視覚コンテンツのテキスト代替を提供
- コンテンツ解析の互換性をテスト

## 必須：質問ファイル形式
**重要**：フェーズで質問をする際は、質問フォーマットのガイドラインに従う必要があります。

**完全な質問フォーマットルールについては、`common/question-format-guide.md`を参照してください**：
- 多肢選択形式（A、B、C、D、Eオプション）
- [Answer]:タグの使用
- 回答の検証と曖昧さの解決

## 必須：カスタムウェルカムメッセージ
**重要**：ソフトウェア開発要求を開始する際は、ウェルカムメッセージを表示する必要があります。

**ウェルカムメッセージの表示方法**：
1. `.kiro/aws-aidlc-rule-details/common/welcome-message.md`または`.amazonq/aws-aidlc-rule-details/common/welcome-message.md`からウェルカムメッセージを読み込む
2. ユーザーに完全なメッセージを表示する
3. これは新しいワークフローの開始時に1回のみ実行する
4. コンテキストスペースを節約するため、後続のインタラクションではこのファイルを読み込まない

# 適応型ソフトウェア開発ワークフロー

---

# 🔵 INCEPTIONフェーズ

**目的**：計画、要件収集、アーキテクチャ決定

**焦点**：何を構築するか、なぜ構築するかを決定

**INCEPTIONフェーズのステージ**：
- ワークスペース検出（常時）
- リバースエンジニアリング（条件付き - ブラウンフィールドのみ）
- 要件分析（常時 - 適応的な深度）
- ユーザーストーリー（条件付き）
- ワークフロー計画（常時）
- アプリケーション設計（条件付き）
- ユニット生成（条件付き）

---

## ワークスペース検出（常に実行）

1. **必須**：audit.mdに完全な生の入力で初期ユーザー要求を記録
2. `inception/workspace-detection.md`からすべてのステップを読み込む
3. ワークスペース検出を実行：
   - 既存のaidlc-state.mdをチェック（見つかった場合は再開）
   - 既存コードのワークスペースをスキャン
   - ブラウンフィールドかグリーンフィールドかを判定
   - 既存のリバースエンジニアリング成果物をチェック
4. 次のフェーズを決定：リバースエンジニアリング（ブラウンフィールドで成果物がない場合）または要件分析
5. **必須**：audit.mdに調査結果を記録
6. ユーザーに完了メッセージを提示（メッセージ形式についてはworkspace-detection.mdを参照）
7. 自動的に次のフェーズに進む

## リバースエンジニアリング（条件付き - ブラウンフィールドのみ）

**実行条件**：
- 既存のコードベースが検出された
- 以前のリバースエンジニアリング成果物が見つからない

**スキップ条件**：
- グリーンフィールドプロジェクト
- 以前のリバースエンジニアリング成果物が存在する

**実行内容**：
1. **必須**：audit.mdにリバースエンジニアリングの開始を記録
2. `inception/reverse-engineering.md`からすべてのステップを読み込む
3. リバースエンジニアリングを実行：
   - すべてのパッケージとコンポーネントを分析
   - ビジネストランザクションをカバーするシステム全体のビジネス概要を生成
   - アーキテクチャドキュメントを生成
   - コード構造ドキュメントを生成
   - APIドキュメントを生成
   - コンポーネントインベントリを生成
   - コンポーネント間でビジネストランザクションがどのように実装されているかを示すインタラクション図を生成
   - テクノロジースタックドキュメントを生成
   - 依存関係ドキュメントを生成

4. **明示的な承認を待つ**：詳細な完了メッセージを提示（メッセージ形式についてはreverse-engineering.mdを参照） - ユーザーが確認するまで進めない
5. **必須**：audit.mdにユーザーの応答を完全な生の入力で記録

## 要件分析（常に実行 - 適応的な深度）

**常に実行されます**が、要求の明確さと複雑さに基づいて深度が変化します：
- **最小限**：シンプルで明確な要求 - 意図分析を文書化するだけ
- **標準**：通常の複雑さ - 機能要件と非機能要件を収集
- **包括的**：複雑で高リスク - トレーサビリティを持つ詳細な要件

**実行内容**：
1. **必須**：このフェーズ中のすべてのユーザー入力をaudit.mdに記録
2. `inception/requirements-analysis.md`からすべてのステップを読み込む
3. 要件分析を実行：
   - リバースエンジニアリング成果物を読み込む（ブラウンフィールドの場合）
   - ユーザー要求を分析（意図分析）
   - 必要な要件の深度を決定
   - 現在の要件を評価
   - 明確化のための質問をする（必要な場合）
   - 要件ドキュメントを生成
4. 適切な深度で実行（最小限/標準/包括的）
5. **明示的な承認を待つ**：requirements-analysis.md詳細ステップの承認形式に従う - ユーザーが確認するまで進めない
6. **必須**：audit.mdにユーザーの応答を完全な生の入力で記録

## ユーザーストーリー（条件付き）

**インテリジェント評価**：ユーザーストーリーが価値を追加するかを決定するために多要素分析を使用：

**常に実行する場合**（高優先度指標）：
- 新しいユーザー向け機能または機能性
- ユーザーワークフローまたはインタラクションに影響する変更
- 複数のユーザータイプまたはペルソナが関与
- 受け入れ基準が必要な複雑なビジネス要件
- 部門横断的なチーム協力が必要
- 顧客向けAPIまたはサービスの変更
- 新しい製品機能または拡張機能

**実行する可能性が高い場合**（中優先度 - 複雑さを評価）：
- 既存のユーザー向け機能の変更
- ユーザーエクスペリエンスに間接的に影響するバックエンドの変更
- ユーザーワークフローに影響する統合作業
- ユーザーに見える利点を持つパフォーマンス改善
- ユーザーインタラクションに影響するセキュリティ強化
- ユーザーデータまたはレポートに影響するデータモデルの変更

**複雑さに基づく評価**：中優先度のケースでは、以下の場合にユーザーストーリーを実行：
- 要求が複数のコンポーネントまたはサービスに関与
- 変更が複数のユーザータッチポイントにまたがる
- ビジネスロジックが複雑または複数のシナリオがある
- ストーリーで明確化できる曖昧な要件がある
- 実装が複数のユーザージャーニーに影響
- ビジネスへの影響またはリスクが大きい変更

**スキップするのは以下の場合のみ**（低優先度 - シンプルなケース）：
- ユーザーへの影響がゼロの純粋な内部リファクタリング
- 明確で孤立したスコープを持つシンプルなバグ修正
- ユーザー向けの影響がないインフラストラクチャの変更
- 機能変更のない技術的負債のクリーンアップ
- 開発者ツールまたはビルドプロセスの改善
- ドキュメントのみの更新

**評価基準**：疑わしい場合は、以下の場合にユーザーストーリーの包含を優先：
- ビジネス関係者の関与がある要求
- ユーザー受け入れテストを必要とする変更
- 複数の実装アプローチを持つ機能
- チーム間の共通理解から利益を得る作業
- 要件の明確さが価値あるプロジェクト

**評価プロセス**：
1. 要求の複雑さとスコープを分析
2. ユーザーへの影響を特定（直接または間接）
3. ビジネスコンテキストと関係者のニーズを評価
4. チームコラボレーションの利点を考慮
5. ボーダーラインのケースでは包含をデフォルトに

**注意**：要件分析が実行された場合、ストーリーはそれらの要件を参照して構築できます。

**ユーザーストーリーは1つのステージ内に2つのパートがあります**：
1. **パート1 - 計画**：質問を含むストーリー計画を作成、回答を収集、曖昧さを分析、承認を取得
2. **パート2 - 生成**：承認された計画を実行してストーリーとペルソナを生成

**実行内容**：
1. **必須**：このフェーズ中のすべてのユーザー入力をaudit.mdに記録
2. `inception/user-stories.md`からすべてのステップを読み込む
3. **必須**：ユーザーストーリーが必要かを検証するためにインテリジェント評価を実行（user-stories.mdのステップ1）
4. リバースエンジニアリング成果物を読み込む（ブラウンフィールドの場合）
5. 要件が存在する場合は、ストーリーを作成する際にそれらを参照
6. 適切な深度で実行（最小限/標準/包括的）
7. **パート1 - 計画**：質問を含むストーリー計画を作成、ユーザーの回答を待つ、曖昧さを分析、承認を取得
8. **パート2 - 生成**：承認された計画を実行してストーリーとペルソナを生成
9. **明示的な承認を待つ**：user-stories.md詳細ステップの承認形式に従う - ユーザーが確認するまで進めない
10. **必須**：audit.mdにユーザーの応答を完全な生の入力で記録

## ワークフロー計画（常に実行）

1. **必須**：このフェーズ中のすべてのユーザー入力をaudit.mdに記録
2. `inception/workflow-planning.md`からすべてのステップを読み込む
3. **必須**：`common/content-validation.md`からコンテンツ検証ルールを読み込む
4. すべての以前のコンテキストを読み込む：
   - リバースエンジニアリング成果物（ブラウンフィールドの場合）
   - 意図分析
   - 要件（実行された場合）
   - ユーザーストーリー（実行された場合）
5. ワークフロー計画を実行：
   - 実行するフェーズを決定
   - 各フェーズの深度レベルを決定
   - マルチパッケージ変更シーケンスを作成（ブラウンフィールドの場合）
   - ワークフロー視覚化を生成（書き込み前にMermaid構文を検証）
6. **必須**：content-validation.mdルールに従ってファイル作成前にすべてのコンテンツを検証
7. **明示的な承認を待つ**：workflow-planning.mdステップ9の言語を使用して推奨事項を提示し、ユーザーが推奨事項を上書きするコントロールを強調 - ユーザーが確認するまで進めない
8. **必須**：audit.mdにユーザーの応答を完全な生の入力で記録

## アプリケーション設計（条件付き）

**実行条件**：
- 新しいコンポーネントまたはサービスが必要
- コンポーネントメソッドとビジネスルールの定義が必要
- サービス層の設計が必要
- コンポーネント依存関係の明確化が必要

**スキップ条件**：
- 既存のコンポーネント境界内の変更
- 新しいコンポーネントまたはメソッドがない
- 純粋な実装変更

**実行内容**：
1. **必須**：このフェーズ中のすべてのユーザー入力をaudit.mdに記録
2. `inception/application-design.md`からすべてのステップを読み込む
3. リバースエンジニアリング成果物を読み込む（ブラウンフィールドの場合）
4. 適切な深度で実行（最小限/標準/包括的）
5. **明示的な承認を待つ**：詳細な完了メッセージを提示（メッセージ形式についてはapplication-design.mdを参照） - ユーザーが確認するまで進めない
6. **必須**：audit.mdにユーザーの応答を完全な生の入力で記録

## ユニット生成（条件付き）

**実行条件**：
- システムを複数の作業単位に分解する必要がある
- 複数のサービスまたはモジュールが必要
- 構造化された分解が必要な複雑なシステム

**スキップ条件**：
- 単一のシンプルなユニット
- 分解が不要
- 単純な単一コンポーネントの実装

**実行内容**：
1. **必須**：このフェーズ中のすべてのユーザー入力をaudit.mdに記録
2. `inception/units-generation.md`からすべてのステップを読み込む
3. リバースエンジニアリング成果物を読み込む（ブラウンフィールドの場合）
4. 適切な深度で実行（最小限/標準/包括的）
5. **明示的な承認を待つ**：詳細な完了メッセージを提示（メッセージ形式についてはunits-generation.mdを参照） - ユーザーが確認するまで進めない
6. **必須**：audit.mdにユーザーの応答を完全な生の入力で記録

---

# 🟢 CONSTRUCTIONフェーズ

**目的**：詳細設計、NFR実装、コード生成

**焦点**：どのように構築するかを決定

**CONSTRUCTIONフェーズのステージ**：
- ユニットごとのループ（各ユニットに対して実行）：
  - 機能設計（条件付き、ユニットごと）
  - NFR要件（条件付き、ユニットごと）
  - NFR設計（条件付き、ユニットごと）
  - インフラストラクチャ設計（条件付き、ユニットごと）
  - コード生成（常時、ユニットごと）
- ビルドとテスト（常時 - すべてのユニット完了後）

**注意**：各ユニットは次のユニットに移る前に完全に完了します（設計+コード）。

---

## ユニットごとのループ（各ユニットに対して実行）

**各作業単位について、以下のステージを順番に実行：**

### 機能設計（条件付き、ユニットごと）

**実行条件**：
- 新しいデータモデルまたはスキーマ
- 複雑なビジネスロジック
- ビジネスルールの詳細設計が必要

**スキップ条件**：
- シンプルなロジック変更
- 新しいビジネスロジックがない

**実行内容**：
1. **必須**：このステージ中のすべてのユーザー入力をaudit.mdに記録
2. `construction/functional-design.md`からすべてのステップを読み込む
3. このユニットの機能設計を実行
4. **必須**：functional-design.mdで定義された標準化された2オプションの完了メッセージを提示 - 創発的な3オプションの動作を使用しない
5. **明示的な承認を待つ**：ユーザーは「変更を要求」または「次のステージに続行」のいずれかを選択する必要がある - ユーザーが確認するまで進めない
6. **必須**：audit.mdにユーザーの応答を完全な生の入力で記録

### NFR要件（条件付き、ユニットごと）

**実行条件**：
- パフォーマンス要件が存在
- セキュリティの考慮が必要
- スケーラビリティの懸念が存在
- 技術スタックの選択が必要

**スキップ条件**：
- NFR要件がない
- 技術スタックがすでに決定されている

**実行内容**：
1. **必須**：このステージ中のすべてのユーザー入力をaudit.mdに記録
2. `construction/nfr-requirements.md`からすべてのステップを読み込む
3. このユニットのNFR評価を実行
4. **必須**：nfr-requirements.mdで定義された標準化された2オプションの完了メッセージを提示 - 創発的な動作を使用しない
5. **明示的な承認を待つ**：ユーザーは「変更を要求」または「次のステージに続行」のいずれかを選択する必要がある - ユーザーが確認するまで進めない
6. **必須**：audit.mdにユーザーの応答を完全な生の入力で記録

### NFR設計（条件付き、ユニットごと）

**実行条件**：
- NFR要件が実行された
- NFRパターンを組み込む必要がある

**スキップ条件**：
- NFR要件がない
- NFR要件評価がスキップされた

**実行内容**：
1. **必須**：このステージ中のすべてのユーザー入力をaudit.mdに記録
2. `construction/nfr-design.md`からすべてのステップを読み込む
3. このユニットのNFR設計を実行
4. **必須**：nfr-design.mdで定義された標準化された2オプションの完了メッセージを提示 - 創発的な動作を使用しない
5. **明示的な承認を待つ**：ユーザーは「変更を要求」または「次のステージに続行」のいずれかを選択する必要がある - ユーザーが確認するまで進めない
6. **必須**：audit.mdにユーザーの応答を完全な生の入力で記録

### インフラストラクチャ設計（条件付き、ユニットごと）

**実行条件**：
- インフラストラクチャサービスのマッピングが必要
- デプロイメントアーキテクチャが必要
- クラウドリソースの仕様が必要

**スキップ条件**：
- インフラストラクチャの変更がない
- インフラストラクチャがすでに定義されている

**実行内容**：
1. **必須**：このステージ中のすべてのユーザー入力をaudit.mdに記録
2. `construction/infrastructure-design.md`からすべてのステップを読み込む
3. このユニットのインフラストラクチャ設計を実行
4. **必須**：infrastructure-design.mdで定義された標準化された2オプションの完了メッセージを提示 - 創発的な動作を使用しない
5. **明示的な承認を待つ**：ユーザーは「変更を要求」または「次のステージに続行」のいずれかを選択する必要がある - ユーザーが確認するまで進めない
6. **必須**：audit.mdにユーザーの応答を完全な生の入力で記録

### コード生成（常に実行、ユニットごと）

**各ユニットに対して常に実行されます**

**コード生成は1つのステージ内に2つのパートがあります**：
1. **パート1 - 計画**：明示的なステップを含む詳細なコード生成計画を作成
2. **パート2 - 生成**：承認された計画を実行してコード、テスト、成果物を生成

**実行内容**：
1. **必須**：このステージ中のすべてのユーザー入力をaudit.mdに記録
2. `construction/code-generation.md`からすべてのステップを読み込む
3. **パート1 - 計画**：チェックボックス付きのコード生成計画を作成、ユーザーの承認を取得
4. **パート2 - 生成**：承認された計画を実行してこのユニットのコードを生成
5. **必須**：code-generation.mdで定義された標準化された2オプションの完了メッセージを提示 - 創発的な動作を使用しない
6. **明示的な承認を待つ**：ユーザーは「変更を要求」または「次のステージに続行」のいずれかを選択する必要がある - ユーザーが確認するまで進めない
7. **必須**：audit.mdにユーザーの応答を完全な生の入力で記録

---

## ビルドとテスト（常に実行）

1. **必須**：このフェーズ中のすべてのユーザー入力をaudit.mdに記録
2. `construction/build-and-test.md`からすべてのステップを読み込む
3. 包括的なビルドとテストの指示を生成：
   - すべてのユニットのビルド指示
   - ユニットテスト実行指示
   - 統合テスト指示（ユニット間のインタラクションをテスト）
   - パフォーマンステスト指示（該当する場合）
   - 必要に応じて追加のテスト指示（契約テスト、セキュリティテスト、E2Eテスト）
4. build-and-test/サブディレクトリに指示ファイルを作成：build-instructions.md、unit-test-instructions.md、integration-test-instructions.md、performance-test-instructions.md、build-and-test-summary.md
5. **明示的な承認を待つ**：質問する：「**ビルドとテストの指示が完了しました。Operationsステージに進む準備はできていますか？**」 - ユーザーが確認するまで進めない
6. **必須**：audit.mdにユーザーの応答を完全な生の入力で記録

---

# 🟡 OPERATIONSフェーズ

**目的**：将来のデプロイメントとモニタリングワークフローのプレースホルダー

**焦点**：どのようにデプロイして実行するか（将来の拡張）

**OPERATIONSフェーズのステージ**：
- オペレーション（プレースホルダー）

---

## オペレーション（プレースホルダー）

**ステータス**：このステージは現在、将来の拡張のためのプレースホルダーです。

オペレーションステージは最終的に以下を含みます：
- デプロイメントの計画と実行
- モニタリングと可観測性のセットアップ
- インシデント対応手順
- メンテナンスとサポートのワークフロー
- 本番環境準備チェックリスト

**現在の状態**：すべてのビルドとテストのアクティビティはCONSTRUCTIONフェーズで処理されます。

## 主要原則

- **適応的実行**：価値を追加するステージのみを実行
- **透明な計画**：開始前に常に実行計画を表示
- **ユーザーコントロール**：ユーザーはステージの包含/除外を要求できる
- **進捗追跡**：aidlc-state.mdに実行およびスキップされたステージを更新
- **完全な監査証跡**：audit.mdにすべてのユーザー入力とAI応答をタイムスタンプ付きで記録
  - **重要**：提供されたとおりにユーザーの完全な生の入力をキャプチャ
  - **重要**：監査ログでユーザー入力を要約または言い換えない
  - **重要**：承認だけでなく、すべてのインタラクションを記録
- **品質重視**：複雑な変更は完全な処理、シンプルな変更は効率的に
- **コンテンツ検証**：content-validation.mdルールに従ってファイル作成前に常にコンテンツを検証
- **創発的動作なし**：Constructionフェーズは、それぞれのルールファイルで定義された標準化された2オプションの完了メッセージを使用する必要があります。3オプションメニューまたはその他の創発的なナビゲーションパターンを作成しないでください。

## 必須：計画レベルのチェックボックス強制

### 計画実行のための必須ルール
1. **計画チェックボックスを更新せずに作業を完了しない**
2. **計画ファイルに記載されているステップを完了した直後に、そのステップを[x]でマーク**
3. **これは作業が完了したのと同じインタラクションで行う必要がある**
4. **例外なし**：すべての計画ステップの完了はチェックボックスの更新で追跡する必要がある

### 2レベルのチェックボックス追跡システム
- **計画レベル**：各ステージ内の詳細な実行進捗を追跡
- **ステージレベル**：aidlc-state.mdで全体的なワークフローの進捗を追跡
- **即座に更新**：作業が完了したのと同じインタラクションですべての進捗更新を行う

## プロンプトログ記録要件
- **必須**：audit.mdにタイムスタンプ付きですべてのユーザー入力（プロンプト、質問、応答）を記録
- **必須**：提供されたとおりにユーザーの完全な生の入力をキャプチャ（要約しない）
- **必須**：ユーザーに尋ねる前にタイムスタンプ付きですべての承認プロンプトを記録
- **必須**：受信後にタイムスタンプ付きですべてのユーザー応答を記録
- **重要**：常にaudit.mdファイルへの変更を追加編集し、その内容を完全に上書きするツールやコマンドを使用しない
- **重要**：audit.md全体の内容を上書きしてイリケーションを引き起こすファイル書き込みツールやコマンドの使用
- タイムスタンプにはISO 8601形式を使用（YYYY-MM-DDTHH:MM:SSZ）
- 各エントリにステージコンテキストを含める

### 監査ログ形式：
```markdown
## [ステージ名またはインタラクションタイプ]
**タイムスタンプ**：[ISOタイムスタンプ]
**ユーザー入力**：「[完全な生のユーザー入力 - 要約しない]」
**AI応答**：「[AIの応答または実行されたアクション]」
**コンテキスト**：[ステージ、アクション、または行われた決定]

---
```

### audit.mdの正しいツール使用方法

✅ 正しい：

1. audit.mdファイルを読み込む
2. ファイルを追加/編集して変更を加える

❌ 間違い：

1. audit.mdファイルを読み込む
2. 読み込んだ内容に追加したい新しい変更を加えて、audit.mdを完全に上書きする

## ディレクトリ構造

```text
<WORKSPACE-ROOT>/                   # ⚠️ アプリケーションコードはここ
├── [project-specific structure]    # プロジェクトによって異なる（code-generation.mdを参照）
│
├── aidlc-docs/                     # 📄 ドキュメントのみ
│   ├── inception/                  # 🔵 INCEPTIONフェーズ
│   │   ├── plans/
│   │   ├── reverse-engineering/    # ブラウンフィールドのみ
│   │   ├── requirements/
│   │   ├── user-stories/
│   │   └── application-design/
│   ├── construction/               # 🟢 CONSTRUCTIONフェーズ
│   │   ├── plans/
│   │   ├── {unit-name}/
│   │   │   ├── functional-design/
│   │   │   ├── nfr-requirements/
│   │   │   ├── nfr-design/
│   │   │   ├── infrastructure-design/
│   │   │   └── code/               # Markdownサマリーのみ
│   │   └── build-and-test/
│   ├── operations/                 # 🟡 OPERATIONSフェーズ（プレースホルダー）
│   ├── aidlc-state.md
│   └── audit.md
```

**重要なルール**：
- アプリケーションコード：ワークスペースルート（aidlc-docs/には決して入れない）
- ドキュメント：aidlc-docs/のみ
- プロジェクト構造：プロジェクトタイプごとのパターンについてはcode-generation.mdを参照
