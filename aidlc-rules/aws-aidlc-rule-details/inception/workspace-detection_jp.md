# ワークスペース検出

**目的**：ワークスペースの状態を判断し、既存のAI-DLCプロジェクトを確認する

## ステップ1：既存のAI-DLCプロジェクトの確認

`aidlc-docs/aidlc-state.md`が存在するかどうかを確認：
- **存在する場合**：最後のフェーズから再開（以前のフェーズからコンテキストを読み込む）
- **存在しない場合**：新しいプロジェクトの評価を続ける

## ステップ2：既存のコードのワークスペースをスキャン

**ワークスペースに既存のコードがあるかどうかを判断：**
- ソースコードファイル（.java、.py、.js、.ts、.jsx、.tsx、.kt、.kts、.scala、.groovy、.go、.rs、.rb、.php、.c、.h、.cpp、.hpp、.cc、.cs、.fsなど）のワークスペースをスキャン
- ビルドファイル（pom.xml、package.json、build.gradleなど）を確認
- プロジェクト構造の指標を探す
- ワークスペースのルートディレクトリを識別（aidlc-docs/ではない）

**調査結果を記録：**
```markdown
## ワークスペースの状態
- **既存のコード**：[はい/いいえ]
- **プログラミング言語**：[見つかった場合はリスト]
- **ビルドシステム**：[見つかった場合はMaven/Gradle/npmなど]
- **プロジェクト構造**：[モノリス/マイクロサービス/ライブラリ/空]
- **ワークスペースルート**：[絶対パス]
```

## ステップ3：次のフェーズを決定

**ワークスペースが空の場合（既存のコードがない）**：
- フラグを設定：`brownfield = false`
- 次のフェーズ：要件分析

**ワークスペースに既存のコードがある場合**：
- フラグを設定：`brownfield = true`
- `aidlc-docs/inception/reverse-engineering/`の既存のリバースエンジニアリング成果物を確認
- **リバースエンジニアリング成果物が存在する場合**：それらを読み込み、要件分析にスキップ
- **リバースエンジニアリング成果物がない場合**：次のフェーズはリバースエンジニアリング

## ステップ4：初期ステートファイルを作成

`aidlc-docs/aidlc-state.md`を作成：

```markdown
# AI-DLC状態追跡

## プロジェクト情報
- **プロジェクトタイプ**：[グリーンフィールド/ブラウンフィールド]
- **開始日**：[ISOタイムスタンプ]
- **現在のステージ**：INCEPTION - ワークスペース検出

## ワークスペースの状態
- **既存のコード**：[はい/いいえ]
- **リバースエンジニアリングが必要**：[はい/いいえ]
- **ワークスペースルート**：[絶対パス]

## コード配置ルール
- **アプリケーションコード**：ワークスペースルート（aidlc-docs/には決して入れない）
- **ドキュメント**：aidlc-docs/のみ
- **構造パターン**：code-generation.mdの重要なルールを参照

## ステージの進捗
[ワークフローが進行するにつれて入力されます]
```

## ステップ5：完了メッセージを提示

**ブラウンフィールドプロジェクトの場合：**
```markdown
# 🔍 ワークスペース検出完了

ワークスペース分析の調査結果：
• **プロジェクトタイプ**：ブラウンフィールドプロジェクト
• [ワークスペースの調査結果のAI生成サマリー（箇条書き）]
• **次のステップ**：既存のコードベースを分析するために**リバースエンジニアリング**に進みます...
```

**グリーンフィールドプロジェクトの場合：**
```markdown
# 🔍 ワークスペース検出完了

ワークスペース分析の調査結果：
• **プロジェクトタイプ**：グリーンフィールドプロジェクト
• **次のステップ**：**要件分析**に進みます...
```

## ステップ6：自動的に進む

- **ユーザーの承認は不要** - これは情報提供のみです
- 次のフェーズに自動的に進む：
  - **ブラウンフィールド**：リバースエンジニアリング（既存の成果物がない場合）または要件分析（成果物が存在する場合）
  - **グリーンフィールド**：要件分析
